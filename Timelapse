#!/usr/bin/env python3
import argparse, os, time, signal, sys, csv
from datetime import datetime
from picamera2 import Picamera2

stop = False
def handle_sigint(sig, frame):
    global stop
    stop = True
signal.signal(signal.SIGINT, handle_sigint)

def main():
    p = argparse.ArgumentParser(description="Raspberry Pi HQ Camera timelapse")
    p.add_argument("--outdir", default="timelapse_out", help="Output directory")
    p.add_argument("--interval", type=float, default=10.0, help="Seconds between shots")
    p.add_argument("--duration", type=float, default=0.0,
                   help="Total runtime in seconds (0 = until Ctrl+C or --frames reached)")
    p.add_argument("--frames", type=int, default=0, help="Stop after N frames (0 = ignore)")
    p.add_argument("--width", type=int, default=4056, help="Capture width")
    p.add_argument("--height", type=int, default=3040, help="Capture height")
    p.add_argument("--quality", type=int, default=90, help="JPEG quality (1-100)")
    p.add_argument("--iso", type=int, default=0, help="ISO (0 = auto)")
    p.add_argument("--shutter_us", type=int, default=0, help="Shutter speed in microseconds (0 = auto)")
    p.add_argument("--awb", default="auto", help="AWB mode: auto/daylight/cloudy/tungsten/fluorescent")
    p.add_argument("--exposure", default="auto", help="Exposure mode: auto/normal/sport/short/long")
    p.add_argument("--annotate", default="", help="Text overlay in filename (not on image)")
    p.add_argument("--no-video", action="store_true", help="Skip MP4 render at the end")
    p.add_argument("--video-fps", type=int, default=24, help="MP4 frames per second")
    p.add_argument("--video-name", default="timelapse.mp4", help="Output MP4 filename")
    args = p.parse_args()

    os.makedirs(args.outdir, exist_ok=True)
    meta_path = os.path.join(args.outdir, "frames.csv")
    with open(meta_path, "w", newline="") as csvf:
        writer = csv.writer(csvf)
        writer.writerow(["index","timestamp_iso","filename"])

    picam2 = Picamera2()
    config = picam2.create_still_configuration(
        main={"size": (args.width, args.height), "format": "RGB888"},
        buffer_count=2
    )
    picam2.configure(config)

    # Camera controls
    controls = {}
    if args.iso > 0:
        controls["AnalogueGain"] = max(1.0, args.iso / 100.0)  # rough mapping
    if args.shutter_us > 0:
        controls["ExposureTime"] = int(args.shutter_us)
    # AWB/Exposure modes (best-effort)
    awb_map = {
        "auto":"auto","daylight":"daylight","cloudy":"cloudy","tungsten":"tungsten","fluorescent":"fluorescent"
    }
    if args.awb in awb_map:
        controls["AwbEnable"] = True
        controls["AwbMode"] = awb_map[args.awb]
    exp_map = {"auto":"normal","normal":"normal","sport":"sport","short":"short","long":"long"}
    if args.exposure in exp_map:
        controls["AeEnable"] = (args.exposure == "auto" or args.exposure == "normal")
        controls["ExposureMode"] = exp_map[args.exposure]

    picam2.start()
    if controls:
        picam2.set_controls(controls)

    start = time.monotonic()
    next_shot = start
    count = 0
    try:
        while True:
            now = time.monotonic()
            if now >= next_shot:
                count += 1
                ts = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]
                tag = f"_{args.annotate}" if args.annotate else ""
                fname = f"img_{ts}{tag}.jpg"
                fpath = os.path.join(args.outdir, fname)
                picam2.capture_file(fpath, quality=args.quality)

                # Append metadata row
                with open(meta_path, "a", newline="") as csvf:
                    writer = csv.writer(csvf)
                    writer.writerow([count, datetime.now().isoformat(), fname])

                print(f"[{count}] saved {fpath}")

                next_shot += args.interval

            # Exit conditions
            if stop:
                print("Stopping (SIGINT).")
                break
            if args.frames > 0 and count >= args.frames:
                print("Reached frame limit.")
                break
            if args.duration > 0 and (now - start) >= args.duration:
                print("Reached duration limit.")
                break

            time.sleep(0.01)
    finally:
        picam2.stop()

    # Optional video render
    if not args.no-video and count > 0:
        # Use file creation order via glob sorted by name (timestamped)
        print("Rendering MP4…")
        # Safer to write a list file for ffmpeg
        listfile = os.path.join(args.outdir, "frames.txt")
        import glob
        imgs = sorted(glob.glob(os.path.join(args.outdir, "img_*.jpg")))
        with open(listfile, "w") as f:
            for im in imgs:
                f.write(f"file '{os.path.basename(im)}'\n")
        # Run ffmpeg
        mp4_path = os.path.join(args.outdir, args.video_name)
        cmd = (
            f"ffmpeg -y -r {args.video_fps} -f concat -safe 0 -i {listfile} "
            f"-vf 'format=yuv420p' -pix_fmt yuv420p -movflags +faststart {mp4_path}"
        )
        rc = os.system(cmd)
        if rc == 0:
            print(f"MP4 saved: {mp4_path}")
        else:
            print("ffmpeg render failed — you can run the command printed above manually.")

if __name__ == "__main__":
    main()
